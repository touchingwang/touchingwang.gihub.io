---
layout: post
title: '背包问题'
date: 2023-01-30
description: '算法'
tags: '算法'
--- 

个人做这个算法题的时候没有一点思路,可以说想的方面都是错的,一直错了好久。

当自己的解题思路和答案的思路相差很大的时候,我们不能说是因为自己笨,只能说自己接触的少或者并没有去进行深度的理解这种思路。

说一说我遇到这种情况的做法,我是硬着头皮往上去看代码。既然前辈的经验放在那里了,不能说没有解决办法。如果你对研究算法有兴趣也可以尝试一下我的做法。我是对着往上的算法代码一步步的手敲写了出来,当遇到哪一行不理解的,我会慢慢的想一想,最后把代码执行一遍。

最后碰巧我试着把自己认为在它的代码中会出现的问题部分代入它的代码中,发现答案竟然能够解决我认为无法解决的问题。于是我又进一步的探索,最终对这种方法和用这种方法为什么能解决的原因有了深部的了解。



```java
/*
 * 给定n(n<=100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C<=1000)。
 * 问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。
 * 不能将物品i装入多次，也不能只装入部分物品i。
 *
 * 输入格式:
 * 共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。
 *
 * 输出格式:
 * 输出装入背包中物品的最大总价值。
 *
 * 输入样例:
 * 在这里给出一组输入。例如：
 * 5 10      6+3+6=15
 * 2 6              假设最大总价值的数量为x,价值为y
 * 2 3
 * 6 5
 * 5 4
 * 4 6
 * 结尾无空行
 *
 * 输出样例:
 * 在这里给出相应的输出。例如：
 * 15
 */
 ```

### 1.动态规划算法

- 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
- 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
- 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
- 动态规划可以通过填表的方式来逐步推进，得到最优解.

### 2.分析

每次遍历到的第i个物品，根据`w[i]`和`v[i]`来确定是否需要将该物品放入背包中。即对于给定的n个物品，**设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令table[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。**则我们有下面的结果：

- `table[i][0] = table[0][j] = 0`; (即表示 填入表的第一行和第一列是0)
- 当`w[i] > j`时：`table[i][j]=table[i-1][j]` ；(即表示当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略)

- 当`j>=w[i]`时： `table[i][j]=max{v[i-1][j], v[i]+table[i-1][j-w[i]]}`(当准备加入的新增的商品的容量小于等于当前背包的容量，就选择两变量的最大者)
  - `table[i-1][j]`： 就是上一个单元格的装入的最大值；
  - `v[i]`: 表示当前商品的价值 ；
  - `table[i-1][j-w[i]]` ： 装入第`i-1`的类型商品到`剩余空间j-w[i]`的最大值；

### 3.代码实现
```java
public class Knapsack {
    //存在物品重量的数组
    private static int[] w;
    //存放物品价值的数组
    private static int[] v;
    //存放物品的数组
    private static String[] goods;
    //存放物品种类数量
    private static int goodsNum;
    //存放背包问题的填表
    private static int[][] table;
    //记录table表的每一项对应的物品(放入背包的物品的组合)情况
    private static int[][] info;
    /**
     * 构造器
     * @param goods 物品数量
     * @param w 物品重量的数组
     * @param v 物品价值的数组
     * @param capacity 背包的容量
     */
    public Knapsack(String[] goods, int[] w, int[] v, int capacity){
        Knapsack.goods = goods;
        Knapsack.w = w;
        Knapsack.v = v;
        Knapsack.goodsNum = goods.length;
        table = new int[goodsNum + 1][capacity + 1];
        info = new int[goodsNum + 1][capacity + 1];

        handler();
    }
    /**
     * 填表并得到各种方案的方法
     */
    private void handler(){
        // TODO 1. `table[i][0] = table[0][j]; (即表示 填入表的第一行和第一列是0)----但是不用处理，因为int默认是0
        for (int i = 1; i < table.length; i++) { //从1(第二行)开始处理，即不处理第一行)
            for (int j = 1; j < table[0].length; j++) { //从1(第二列)开始处理，即不处理第一列
                /* TODO 2. 当`w[i] > j`时：`table[i][j] = table[i-1][j];
                 * (即表示当准备加入新增的商品的容量大于 当前背包的容量时,就直接使用上一个单元格的装入策略)
                 *
                 * 但是需要注意，因为i和j是从1开始的，因此我们需要进行减1操作，否则就会导致数组的第一个元素无法处理
                 */
                if (w[i-1] > j){
                    table[i][j] = table[i-1][j];
                } else {
                    /* TODO 3.当`j >= w[i]`时：`table[i][j] = max{table[i-1][j], v[i] + table[i-1][j-w[i]]}`
                     * 当准备加入的新增的商品的容量小于等于当前背包的容量，就选择两变量的最大者
                     *
                     * 但是需要注意，因为i和j是从1开始的，因此我们需要进行减1操作，否则就会导致数组的第一个元素无法处理
                     */
                    if (table[i-1][j] < v[i-1] + table[i-1][j-w[i-1]]){
                        table[i][j] = v[i-1] + table[i-1][j-w[i-1]];
                        //将当前项的情况记录到info
                        info[i][j]=1;
                    } else {
                        table[i][j] = table[i-1][j];
                    }
                }
            }
        }
    }

    /*
     * 显示填表之后的表
     */
    public void showTable() {
        for (int[] ints : table) {
            for (int j = 0; j < table[0].length; j++) {
                System.out.print(ints[j] + "\t");
            }
            System.out.println();
        }
    }

    /*
     * 显示填表的表的每一项对应的取值(放入背包的物品)
     */
    public void showInfo() {
        for (int i = 0; i < info.length; i++) {
            for (int j = 0; j < info[0].length; j++) {
                if(info[i][j] == 1) {
                    System.out.print("将物品《"+goods[i-1]+"》放入凯普斯背包\t");
                }
            }
            System.out.println();
        }

        System.out.println("\n\n========最优解：");
        int i = info.length - 1; //获取列(当前的物品)的最大下标
        int j = info[0].length - 1; //获取行(背包的当前容量的最大下标)
        while (i > 0 && j > 0){ //从最后开始遍历查找(表的最后是最优解)
            if(info[i][j] == 1){
                System.out.print("将物品《"+goods[i-1]+"》放入背包，\t");
                j -= w[i-1]; //将背包的容量根据放入的物品做减
            }
            i--; //进行下一个物品的处理
        }
        System.out.println("此时背包价值：￥"+table[table.length-1][table[0].length-1]);
    }

    public static void main(String[] args) {
        // // TODO 物品的数组
        // String[] goods = { "40个树枝", "40个草", "3个金币", "40块石头", "2个金块", "一颗紫宝石", "一块月岩" };
        // // TODO 物品重量的数组
        // int[] w = { 10, 10, 3, 20, 2, 5, 30 };
        // // TODO 物品价值的数组
        // int[] val = { 1000, 1000, 3000, 2000, 4000, 6000, 10000 };
        // // TODO 背包容量
        // int capacity = 40;
        //===========================================================================================
        // TODO 物品的数组
        String[] goods = { "2个6", "2个3", "6个5", "5个4", "4个6"};
        // TODO 物品重量的数组
        int[] w = { 2, 2, 6, 5, 4 };
        // TODO 物品价值的数组
        int[] val = { 6, 3, 5, 4, 6 };
        // TODO 背包容量
        int capacity = 10;

        Knapsack knapsack = new Knapsack(goods, w, val, capacity);

        // 显示填表的结果
        knapsack.showTable();

        // TODO 显示填表的每一项对应的取值(放入背包的物品)
        knapsack.showInfo();
    }
}
```

### 4.测试结果
![pSwZhL9.png](https://s1.ax1x.com/2023/01/30/pSwZhL9.png)
