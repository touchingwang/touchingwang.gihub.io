---
layout: post
title: '吸血鬼数字'
date: 2023-01-10
description: '算法'
tags: '算法'
--- 

我发现算法比较神奇的是写着写着的最优解就会涉及到数学上的公式。每发现一种公式,我就像在游戏中看到游戏攻略般震惊。

```java
/*
 * 吸血鬼数字是指位数为偶数的数字,可以由一对数字相乘而得到,而这对数字各包含乘积的一半位数的数字,其中从最初的数字中选取的数字可以任意排序。
 * 以两个0结尾的数字是不允许的,例如,下列数字都是“吸血鬼”数字:
 * 1260 = 21 * 60
 * 1827 = 21 * 87
 * 2187 = 27 * 81
 * 写一个程序,找出4位数的所有吸血鬼数字(Dan Forhan推荐)
 * */
 ```
### 1.我的解法、字符串拆除比较

**思路**：z=x*y,把z转换为字符串,将x,y转换为四位char字符,通过String.replaceFirst来把字符串z进行替换为空,如果最终的长度为0,则满足条件。比较使用了6550次

我的方法中 j 循环,`j=min`可以进行优化`j=i+1`;这样写比较次数会减半三千左右

 ```java
    public static void main(String[] args) {
        int min = 1000/99 +1; //1000.00/99=10.101010 min=11
        int max = 99;
        int size = 0;
        ArrayList<String> strList = new ArrayList<>();
        for (int i = min;i <= max;i++){
            for (int j = min;j <= max;j++){
                if(i*j<=1000||i*j>=9999){
                    continue;
                }
                if(i%10==0&&j%10==0){
                    continue;
                }
                size++;
                char a = (char) (i/10+'0');
                char b = (char) (i%10+'0');
                char c = (char) (j/10+'0');
                char d = (char) (j%10+'0');
                String strMult = (""+i*j);
                String s = strMult.replaceFirst(String.valueOf(a), "")
                        .replaceFirst(String.valueOf(b), "")
                        .replaceFirst(String.valueOf(c), "")
                        .replaceFirst(String.valueOf(d), "");
                if (s.length()!=0){
                    continue;
                }
                if(!strList.contains(strMult)){
                    strList.add(strMult);
                    System.out.println(strMult+" "+i+" "+j);
                }
            }
        }
        System.out.println("size="+size);
    }
```
最终结果
```java
1395 15 93
1260 21 60
1827 21 87
2187 27 81
1530 30 51
1435 35 41
6880 80 86
size=6550
```
### 2.最优解法:利用了数字的位数拆分，通过算法满足条件

该方法直接将比较次数降低了10倍,大概三百次比较(降为打击！)

```java
//: control/E10_Vampire.java
/******************
 * Exercise 10 ********************* A vampire number has an even number of
 * digits and is formed by multiplying a pair of numbers containing half the
 * number of digits of the result. The digits are taken from the original number
 * in any order. Pairs of trailing zeroes are not allowed. Examples include:
 * 1260 = 21 * 60 1827 = 21 * 87 2187 = 27 * 81 Write a program that finds all
 * the 4-digit vampire numbers. (Suggested by Dan Forhan.)
 * 
 * 中文翻译：
 * 一个吸血鬼数字有偶数个数字，它是由一对数字相乘而成，其中的一半是吸血鬼的
 * 结果的位数。这些数字取自原始数字
 * 在任何顺序。不允许有一对尾随的0。例子包括:
 * 1260 = 21 * 60 1827 = 21 * 87 2187 = 27 * 81编写一个程序，找出所有
 * 4位数的吸血鬼号码。(Dan Forhan建议)
 ****************************************************/
public class E10_Vampire {
	public static void main(String[] args) {
		int sign = 0;//计数器，计比较次数
		int[] startDigit = new int[4]; //创建两个储存两位数的数组
		int[] productDigit = new int[4];
		for (int num1 = 10; num1 <= 99; num1++) //寻找第一个两位数
			for (int num2 = num1; num2 <= 99; num2++) { //寻找第二个两位数
				// Pete Hartley's theoretical result:
				// If x·y is a vampire number then
				// x·y == x+y (mod 9)
				
				// 中文翻译：
				// Pete Hartley的理论结果:
				// 如果x·y是吸血鬼的号码
				// 就满足这个条件 x·y == x+y (mod 9)
				if ((num1 * num2) % 9 != (num1 + num2) % 9)
					continue; //如果满足条件就继续下去
				sign++;//计数
				int product = num1 * num2; //两个两位数相乘
				startDigit[0] = num1 / 10; //以下内容就是分别计算出两个两位数的十位、个位（即、把他们拆分成单个数字）
				startDigit[1] = num1 % 10;
				startDigit[2] = num2 / 10;
				startDigit[3] = num2 % 10;
				productDigit[0] = product / 1000; //以下内容就是分别计算出乘积的十位、个位、百位、千位（即、把他们拆分成单个数字）
				productDigit[1] = (product % 1000) / 100;
				productDigit[2] = product % 1000 % 100 / 10;
				productDigit[3] = product % 1000 % 100 % 10;
				int count = 0; //计数器
				for (int x = 0; x < 4; x++) //两个循环遍历数组中两个两位数拆分出来的单数字与乘积拆分出来的单数字
					for (int y = 0; y < 4; y++) {
						if (productDigit[x] == startDigit[y]) { //让两个数组中的数字进行比较
							count++; //满足条件即开始计数
							productDigit[x] = -1; //因为假如左边数组4个数字、右边数组4个数字，让左边的遍历去进行和右边的比较
							startDigit[y] = -2;   //就像连线一样，我们满足条件之后也会多比较一次相同的数字，我们就想办法避免
							                      //这个重复的比较，所以进行了对这个数组下标值得改变，因此避免了这个问题
							                      //比如：数字中出现重复数字，如果不将左右值变了的话，就会出现和重复的值比较
							if (count == 4) //满足4个单数字都相等即计数器计了4次数，满足了吸血鬼数字
								System.out.println(num1 + " * " + num2 + " : " + product); //打印所有吸血鬼数字
						}
					}
			}
		System.out.println("count = " + sign);
	}
}
```

### 3.最优解法数学公式 x·y == x+y (mod 9)
```vue
int product = num1 * num2;
product= 1000a + 100b + 10c + d；
因为
num1 = 10a + b
num2 = 10c + d
则 product - num1 - num2
  =1000a + 100b + 10c + d - （10a + b）- （10c + d）
  =990a + 99b = 9 * (110a + 11b)
所以product- num1 - num2能被9整除。
```

<br>

转载请注明：[touchingwang的博客](http://touchingwang.github.io) » [点击阅读原文](http://https://github.com/touchingwang/touchingwang.github.io/tree/master/_posts/2022-12-07-Bean&Map.md)