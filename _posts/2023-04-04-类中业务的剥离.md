---
layout: post
title: '类中AOP切面使用'
date: 2023-04-04
description: '类中AOP切面使用'
tags: '技术'
--- 

这两天看设计模式原则，看到了单一职责原则。单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。SRP原则的解释是：There should never be more than one reason for a class to change。定义很简单，即不能存在多于一个导致类变更的原因。简单的说就是一个类只负责一项职责。

突发奇想，我们日常开发中会有写到对传参`paramMap`的判断，想把它单独提出来作为一个类。
```java
import org.cn.codeTemp.util.TouUtils;
@Service
public class CarServiceImpl extends ServiceImpl<CarMapper, Car> implements CarService{
    private EntityResult result = new EntityResult<>();
    @Override
    public EntityResult Query(Map<String, Object> paramMap) {
       try {
           TouUtils.isBlankIfStr(paramMap);
       }catch (Exception e) {
           return ResultHandler.operError(e);
       }
       result.setRows(this.getBaseMapper().selectList(new QueryWrapper<Car>().lambda()));
       return result;
    }
}
```
平时写接口的时候，我们的第一步往往是先判断传参`paramMap`是否为空以及数据库中是否存在传递参数。如果是复杂的业务编写会导致接口显得很冗余。
这里，我把参数判断的职责分离出来。写了一个类单一职责是判断参数是否正确有效(参数为空或数据库存在参数)


```java
public class TouUtils {
    public static void isBlankIfStr(Map<String, Object> paramMap) throws Exception{
        if(StrUtil.isBlankIfStr(paramMap.get("Id")))
            throw new Exception("id为空");
        if(StrUtil.isBlankIfStr(paramMap.get("Code")))
            throw new Exception("编码为空");
        if(StrUtil.isBlankIfStr(paramMap.get("Name")))
            throw new Exception("名称为空");
    }
}
```
我一开始不是用try，catch异常处理操作的，执行一遍发现没有进行判断。打了断点之后发现是因为没有抛出异常；未接收就继续执行了

```java
    public static <T> EntityResult<T> operError(Exception e) {
        EntityResult<T> optResult = new EntityResult<T>();
        optResult.setResult(SuccessEnum.Error.getResult());
        optResult.setMsg(String.valueOf(e).replace("java.lang.Exception: ",""));
        return optResult;
    }
```
对于异常处理`ResultHandler.operError(e);`重载了ResultHandler类内的方法

之后我由想到了,有没有一个操作可以在执行这个方法的时候横切进去判断，如果用AOP可以实现操作。

```java
@Aspect
@Component
public class TouUtils {
    @Pointcut("execution(public * org.cn.codeTemp.service.impl.TVlDbCarTypeServiceImpl.*(..))..*)")
    public void execute() {
    }

    @Before("execute()")
    public void beforeAdvice(JoinPoint joinPoint) throws Exception{
        Map params = AopHelper.getMethodParams(joinPoint);
        System.out.println("=========");
        Console.log(params);
        System.out.println("=========");
        params.forEach((key,value)->{
            if (value.equals("Id")&&StrUtil.isBlankIfStr(value))
                throw new RuntimeException("id为空");
            if (value.equals("Code")&&StrUtil.isBlankIfStr(value))
                throw new RuntimeException("编码为空");
            if (value.equals("Name")&&StrUtil.isBlankIfStr(value))
                throw new RuntimeException("名称为空");
        });
    }
}
```
但是失败了，我这里一直无法捕获到异常处理...目前就采用上面一种方式了。
