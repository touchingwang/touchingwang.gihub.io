---
layout: post
title: '数据库表的生成'
date: 2022-12-19
description: 'esayCode与mybatisPlus代码生成器'
tags: '技术'
--- 

### 欢迎来玩我的世界

我们在开发的时候,有时候需要进行一些低代码的开发工作,生成大量的数据表,并做一个个的Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码,不仅枯燥而且开发效率很慢。听说市面上有类似的数据库表生成工具,比如代码类的mybatisPlus、插件类的easyCode等等。它们可以通过一些简单的学习,就能够帮助我们快速生成各个模块代码,极大的提升了开发效率。

### MyBatis-Plus 的代码生成器
mybatisPlus的代码生成器,通过导入两个依赖,然后写一个类,我们通过执行类,就可以创建出对应模块的代码,可以说只需要编写一个类,就实现了我们所有数据库表需要生成的代码。常见的问题是依赖的版本问题,所需要的依赖之一 mybatis-plus-generator 在 3.5.1 以下和 3.5.1 以上还是有不少变动的。我这里给了3.5.1以下的模板参考使用。

#### 1.导入依赖
想要使用mybatisPlus的代码生成器,我们需要导入他们开发的工具包。
这里加入了一个 `mybatis-plus-boot-starter` 依赖版本,有时候出现问题也可能是因为这个的版本冲突.
```xml
<!-- mybatisPlus 代码生成器 -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.3.1</version>
</dependency>
<dependency>
    <groupId>org.apache.velocity</groupId>
    <artifactId>velocity-engine-core</artifactId>
    <version>2.3</version>
</dependency>

<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.1</version>
</dependency>
```

#### 2.编写对应的Generator,我们可以单独创建一个config或其他文件,把它放到里面
```java
public class MybatisPlusGenerator {
    public static void main(String[] args) {
        // 全局配置
        GlobalConfig config = new GlobalConfig();
        config.setActiveRecord(false);//是否支持AR模式
        config.setAuthor("***");//作者
        config.setOutputDir(System.getProperty("user.dir") + "\\src\\main\\java");//生成路径
        config.setFileOverride(true);//文件覆盖
        config.setIdType(IdType.AUTO);//自增策略
        config.setServiceName("I%sImpl");//设置生成的service接口的名字首字母是否有I
        config.setBaseResultMap(true);
        config.setBaseColumnList(true);
        //2.数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setDbType(DbType.MYSQL);//设置数据库类型
        dsc.setUrl("jdbc:mysql://***:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=false");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("******");
        dsc.setPassword("******");
        //3.策略配置
        StrategyConfig strategyConfig = new StrategyConfig();
        strategyConfig.setCapitalMode(true);//开启全局大写命名
        strategyConfig.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
        strategyConfig.setTablePrefix();//表的前缀
        strategyConfig.setInclude();//需要生成的表,如果不写,会生成数据库下所有表
        //4.包名策略配置
        PackageConfig pc = new PackageConfig();
        pc.setParent("com.whh.demo")
                .setEntity("entity.bd")
                .setMapper("mapper.bd")
                .setServiceImpl("service.biz.bd")
                .setService("service.ibiz.bd")
                .setController("")
                .setXml("mybatis.bd");
        //5.整合配置
        AutoGenerator autoGenerator = new AutoGenerator();
        autoGenerator.setGlobalConfig(config)
                .setDataSource(dsc)
                .setStrategy(strategyConfig)
                .setPackageInfo(pc);
        //6.执行
        autoGenerator.execute();
    }
}
```

#### 3.执行类代码,如果成功,会生成对应的类
对应的文件夹内生成对应各个模块的代码:

[![pSu2Yad.png](https://s1.ax1x.com/2023/01/12/pSu2Yad.png)](https://imgse.com/i/pSu2Yad)

### esaycode辅助开发插件

基于IntelliJ IDEA开发的代码生成插件，支持自定义模板。号称只要是与数据库相关的代码都可以通过自定义模板来生成。支持数据库类型与java类型映射关系配置。一开始我也是不相信的,后来发现真香。

该插件的好处是和mybatisPlus代码生成器比,好用,方便。可以说是碾压,降为打击。如果你用idea,就直接使用它吧。
缺点也有：该插件使用只能在idea上操作,同时需要会一点idea连接数据库操作。

#### 1.使用idea安装easycode插件
找到设置,点击 plugins, 搜索 easycode 点击 install

[![pSu2aGt.md.png](https://s1.ax1x.com/2023/01/12/pSu2aGt.md.png)](https://imgse.com/i/pSu2aGt)

#### 2.使用idea连接数据库
对于使用idea的开发人员来说,这一步就是日常喝水。
点击view,点击Tool Windows,选中Database,之后我们idea的右侧边栏就有了Database工具,如果没有Database,那就换成旗舰版吧,社区版没有对应的功能,一个好的开发工具会是成功的一半。

[![pSu2UPI.md.png](https://s1.ax1x.com/2023/01/12/pSu2UPI.md.png)](https://imgse.com/i/pSu2UPI)

点击选中Database选择mysql连接数据库,如果出现一下其他区域时间问题等可直接百度,idea的社区还是很活跃的。

[![pSu2JVH.md.png](https://s1.ax1x.com/2023/01/12/pSu2JVH.md.png)](https://imgse.com/i/pSu2JVH)

#### 2.使用easycode
打开database,右键需要生成的表,选中EasyCode选中GenerateCode
之后回出现可视化的生成界面

Module 生成代码的模块
统一配置：当我们生成多个表的时候会有一下路径问题，我们选中统一配置,所有的路径都会统一了。

[![pSu28qe.md.png](https://s1.ax1x.com/2023/01/12/pSu28qe.md.png)](https://imgse.com/i/pSu28qe)

[![pSu2tIA.png](https://s1.ax1x.com/2023/01/12/pSu2tIA.png)](https://imgse.com/i/pSu2tIA)

#### 3.自定义使用easycode
使用默认的easycode我们就可以生成各种模块的代码了,然后将我们需要的代码移动过去就行。
有人说,这样也太麻烦了,而且生成的代码有一部分用不到看着比较烦,能不能自定义生成的代码。

easycode的自定义模块就能满足你的需求。
我们可以在设置的Other Settings中选中EasyCode的Template就可以编写模板了,我们可以添加自己的代码,比如每生成一个表的代码的时候生成一个readme.md文件,可以在代码里面添加注解,导入类,修改文件路径等等。我这里给出了我自己采用的一个模板。

[![pSu2dRP.md.png](https://s1.ax1x.com/2023/01/12/pSu2dRP.md.png)](https://imgse.com/i/pSu2dRP)

##### entity.java.vm
```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("")

##保存文件（宏定义）
#save("/entity", ".java")

##包路径（宏定义）
#setPackageSuffix("entity")

##自动导入包（全局变量）
$!{autoImport.vm}
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import java.io.Serializable;
import lombok.NoArgsConstructor;
import lombok.Data;

##表注释（宏定义）
#tableComment("表实体类")
@Data
@NoArgsConstructor
@TableName("$tableInfo.name")
public class $!{tableName} implements Serializable {
##以第一个primary key字段没primary key
#foreach($column in $tableInfo.pkColumn)
    #set($pkColumn = $!column.name)
    #break
#end

##输出每个字段
#foreach($column in $tableInfo.fullColumn)
    #if(${column.comment})
    /**
        * ${column.comment}
        */
    #end
    #if(${column.name} == ${pkColumn})
@TableId(value = "$tool.hump2Underline($column.name)")
    #end
private $!{tool.getClsNameByFullName($column.type)} $!{column.name};
    
#end
}
```

##### mapper.java.vm
```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("Mapper")

##保存文件（宏定义）
#save("/mapper", "Mapper.java")

##包路径（宏定义）
#setPackageSuffix("mapper")

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import $!{tableInfo.savePackageName}.entity.$!tableInfo.name;
import org.apache.ibatis.annotations.Mapper;

##表注释（宏定义）
#tableComment("表数据库访问层")
@Mapper
public interface $!{tableName} extends BaseMapper<$!tableInfo.name> {

}
```

##### mapper.xml.vm
```java
##引入mybatis支持
$!{mybatisSupport.vm}

##设置保存名称与保存位置
$!callback.setFileName($tool.append($!{tableInfo.name}, "Mapper.xml"))
$!callback.setSavePath($tool.append($modulePath, "/src/main/resources/mybatis"))

##拿到主键
#if(!$tableInfo.pkColumn.isEmpty())
    #set($pk = $tableInfo.pkColumn.get(0))
#end

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="$!{tableInfo.savePackageName}.mapper.$!{tableInfo.name}Mapper">
</mapper>
```

##### service.java.vm
```java
##类名的Repository
#set($tableName = $tool.append("I",$tableInfo.name, "Impl"))
##设置回调  
##设置文件储存名字($tool.append($tableName, ".java"))
$!callback.setFileName(${tool.append($tableName, ".java")})
##设置文件储存路径，默认使用选中路径
$!callback.setSavePath($tool.append($tableInfo.savePath, "/service/ibiz"))
#if($tableInfo.savePackageName)package $!{tableInfo.savePackageName}.#{end}service.ibiz;

/**
 * $!{tableInfo.comment}($!{tableInfo.name})表数据库访问层
 *
 * @author $!author
 * @since $!time.currTime()
 */
public interface $!{tableName}{
}
```

##### serviceImpl.java.vm
```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("Impl")

##保存文件（宏定义）
#save("/service/biz", "Impl.java")

##包路径（宏定义）
#setPackageSuffix("service.biz")

import  $!{tableInfo.savePackageName}.service.ibiz.I$!{tableInfo.name}Impl;
import org.springframework.stereotype.Service;

##表注释（宏定义）
#tableComment("表服务实现类")
@Service
public class $!{tableName} implements I$!{tableInfo.name}Impl {
}
```

##### controller.java.vm
controller这部分没用过,模板也没有改为默认的

<br>

转载请注明：[touchingwang的博客](http://touchingwang.github.io) » [点击阅读原文](http://https://github.com/touchingwang/touchingwang.github.io/tree/master/_posts/2022-12-19-easycode.md)
